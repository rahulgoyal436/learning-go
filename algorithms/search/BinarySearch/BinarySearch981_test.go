// ********RoostGPT********
/*
Test generated by RoostGPT for test roost_test using AI Type  and AI Model 

ROOST_METHOD_HASH=binarySearch_5149337a0e
ROOST_METHOD_SIG_HASH=binarySearch_7d22ad2576

Scenario 1: Query Item Exists at the Middle of the Array

Details:
    Description: This test aims to verify the correct functionality of the binarySearch function when the query item exists exactly at the middle of the array.
Execution:
    Arrange: An array of integers sorted in ascending order and a query integer that exists exactly at the middle of the array.
    Act: Invoke the binarySearch function with the arranged array and query.
    Assert: Use the Go testing facilities to verify that the returned index is the middle index of the array.
Validation:
    The choice of assertion is based on the principle of binary search where the middle item of the array is checked first. This test is important to ensure that the function behaves as expected in a standard scenario.

Scenario 2: Query Item Exists at the Beginning of the Array

Details:
    Description: This test aims to verify the correct functionality of the binarySearch function when the query item exists at the beginning of the array.
Execution:
    Arrange: An array of integers sorted in ascending order and a query integer that exists at the beginning of the array.
    Act: Invoke the binarySearch function with the arranged array and query.
    Assert: Use the Go testing facilities to verify that the returned index is zero.
Validation:
    The choice of assertion is based on the principle of binary search where the search space is halved after each comparison. This test is important to ensure that the function behaves as expected when the query exists at the beginning of the array.

Scenario 3: Query Item Exists at the End of the Array

Details:
    Description: This test aims to verify the correct functionality of the binarySearch function when the query item exists at the end of the array.
Execution:
    Arrange: An array of integers sorted in ascending order and a query integer that exists at the end of the array.
    Act: Invoke the binarySearch function with the arranged array and query.
    Assert: Use the Go testing facilities to verify that the returned index is the last index of the array.
Validation:
    The choice of assertion is based on the principle of binary search where the search space is halved after each comparison. This test is important to ensure that the function behaves as expected when the query exists at the end of the array.

Scenario 4: Query Item Does Not Exist in the Array

Details:
    Description: This test aims to verify the correct functionality of the binarySearch function when the query item does not exist in the array.
Execution:
    Arrange: An array of integers sorted in ascending order and a query integer that does not exist in the array.
    Act: Invoke the binarySearch function with the arranged array and query.
    Assert: Use the Go testing facilities to verify that the returned index is -1.
Validation:
    The choice of assertion is based on the function's specification that it should return -1 when the query does not exist in the array. This test is important to ensure that the function behaves as expected when the query does not exist in the array.

Scenario 5: Empty Array

Details:
    Description: This test aims to verify the correct functionality of the binarySearch function when the array is empty.
Execution:
    Arrange: An empty array and any integer query.
    Act: Invoke the binarySearch function with the arranged array and query.
    Assert: Use the Go testing facilities to verify that the returned index is -1.
Validation:
    The choice of assertion is based on the function's specification that it should return -1 when the array is empty. This test is important to ensure that the function behaves as expected when the array is empty.
*/

// ********RoostGPT********
package BinarySearch

import "testing"

func TestBinarySearch981(t *testing.T) {
	
	testCases := []struct {
		name     string
		arr      []int
		query    int
		expected int
	}{
		{"MiddleElement", []int{1, 2, 3, 4, 5}, 3, 2},
		{"FirstElement", []int{1, 2, 3, 4, 5}, 1, 0},
		{"LastElement", []int{1, 2, 3, 4, 5}, 5, 4},
		{"ElementNotInArray", []int{1, 2, 3, 4, 5}, 6, -1},
		{"EmptyArray", []int{}, 1, -1},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := binarySearch(tc.arr, tc.query)
			if result != tc.expected {
				t.Fatalf("Expected %v, but got %v", tc.expected, result)
			}
		})
	}
}
,[object Object]