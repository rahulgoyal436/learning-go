// ********RoostGPT********
/*
Test generated by RoostGPT for test roost_test using AI Type  and AI Model 

Test generated by RoostGPT for test roost_test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=binarySearch_5149337a0e
ROOST_METHOD_SIG_HASH=binarySearch_7d22ad2576

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/search/BinarySearch/binarysearch_test.go
Test Cases:
    [TestBinarySearch]

Scenario 1: Binary Search with Query Present in the Array

Details:
  Description: This test is meant to check that the binarySearch function correctly returns the index of a query item if it is present in the array.

Execution:
  Arrange: Prepare an array of integers with a known order. Select a query item that is known to be in the array.
  Act: Invoke the binarySearch function with the prepared array and query item.
  Assert: Confirm that the returned index corresponds to the position of the query item in the array.

Validation:
  The choice of assertion verifies that the binarySearch function is correctly identifying the location of a query item within the array. This test is crucial for confirming the basic functionality of the binarySearch function.

Scenario 2: Binary Search with Query Not Present in the Array

Details:
  Description: This test is meant to check that the binarySearch function correctly returns -1 when the query item is not present in the array.

Execution:
  Arrange: Prepare an array of integers with a known order. Select a query item that is known to be absent from the array.
  Act: Invoke the binarySearch function with the prepared array and query item.
  Assert: Confirm that the returned index is -1.

Validation:
  The choice of assertion verifies that the binarySearch function is correctly handling the scenario where the query item is not found in the array. This test is important for ensuring the binarySearch function behaves as expected when the query item is not present.

Scenario 3: Binary Search with Empty Array

Details:
  Description: This test is meant to check that the binarySearch function correctly returns -1 when the array is empty, regardless of the query item.

Execution:
  Arrange: Prepare an empty array.
  Act: Invoke the binarySearch function with the empty array and any integer as the query item.
  Assert: Confirm that the returned index is -1.

Validation:
  The choice of assertion verifies that the binarySearch function is correctly handling the scenario where the array is empty. This test is important for ensuring the binarySearch function behaves as expected when provided with an empty array.

Scenario 4: Binary Search with Single-Element Array

Details:
  Description: This test is meant to check that the binarySearch function correctly handles the edge case of a single-element array.

Execution:
  Arrange: Prepare a single-element array. Select the single element as the query item.
  Act: Invoke the binarySearch function with the single-element array and query item.
  Assert: Confirm that the returned index is 0.

Validation:
  The choice of assertion verifies that the binarySearch function is correctly handling the edge case of a single-element array. This test is important for ensuring the binarySearch function can handle arrays of any size.
*/

// ********RoostGPT********
package BinarySearch

import (
	"testing"
)

func TestBinarySearch848(t *testing.T) {
	testCases := []struct {
		name     string
		arr      []int
		query    int
		expected int
	}{
		{
			name:     "Binary Search with Query Present in the Array",
			arr:      []int{2, 4, 6, 8, 10},
			query:    6,
			expected: 2,
		},
		{
			name:     "Binary Search with Query Not Present in the Array",
			arr:      []int{1, 3, 5, 7, 9},
			query:    2,
			expected: -1,
		},
		{
			name:     "Binary Search with Empty Array",
			arr:      []int{},
			query:    1,
			expected: -1,
		},
		{
			name:     "Binary Search with Single-Element Array",
			arr:      []int{1},
			query:    1,
			expected: 0,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := binarySearch(tc.arr, tc.query)
			if result != tc.expected {
				t.Errorf("For %s, expected %d but got %d", tc.name, tc.expected, result)
			} else {
				t.Logf("Success: %s", tc.name)
			}
		})
	}
}
